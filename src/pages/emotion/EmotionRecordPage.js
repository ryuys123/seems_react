import React, { useState, useEffect, useContext, useRef } from "react";
import styles from "./EmotionRecordPage.module.css";
import UserHeader from "../../components/common/UserHeader";
import { AuthContext } from "../../AuthProvider";

const EmotionRecordPage = () => {
  const [selectedEmotion, setSelectedEmotion] = useState(null);
  const [recordText, setRecordText] = useState("");
  const [emotions, setEmotions] = useState([]);
  const [emotionLogs, setEmotionLogs] = useState([]); // Í∞êÏ†ï Í∏∞Î°ù ÏÉÅÌÉú Ï∂îÍ∞Ä
  const { isLoggedIn, userid, secureApiRequest, updateTodayEmotion } = useContext(AuthContext);

  // ÏùåÏÑ± Ïù∏Ïãù ÏÉÅÌÉú Î∞è Ï∞∏Ï°∞ Ï∂îÍ∞Ä
  const [isListening, setIsListening] = useState(false);
  const recognitionRef = useRef(null);

  //ÌëúÏ†ï Í∏∞Î∞ò Í∞êÏ†ïÎ∂ÑÏÑùÏóê ÌïÑÏöî
  const [showWebcamModal, setShowWebcamModal] = useState(false);
  const videoRef = useRef(null);

  // Í∞êÏ†ï Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
  useEffect(() => {
    const fetchEmotions = async () => {
      try {
        const response = await secureApiRequest(
          "http://localhost:8888/seems/api/emotions"
        );
        setEmotions(response.data);
      } catch (error) {
        console.error("Í∞êÏ†ï Î™©Î°ùÏùÑ Í∞ÄÏ†∏Ïò§Îäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§:", error);
      }
    };

    fetchEmotions();
  }, [secureApiRequest]);

  // ÏÇ¨Ïö©Ïûê Í∞êÏ†ï Í∏∞Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
  useEffect(() => {
    const fetchEmotionLogs = async () => {
      if (isLoggedIn && userid) {
        // Î°úÍ∑∏Ïù∏ ÏÉÅÌÉúÏù¥Í≥† userIdÍ∞Ä ÏûàÏùÑ ÎïåÎßå Ìò∏Ï∂ú
        try {
          const response = await secureApiRequest(
            `http://localhost:8888/seems/api/emotion-logs/${userid}`
          );
          setEmotionLogs(response.data);
        } catch (error) {
          console.error("Í∞êÏ†ï Í∏∞Î°ùÏùÑ Í∞ÄÏ†∏Ïò§Îäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§:", error);
        }
      } else {
        setEmotionLogs([]); // Î°úÍ∑∏ÏïÑÏõÉ ÏÉÅÌÉúÎ©¥ Í∏∞Î°ù ÎπÑÏõÄ
      }
    };

    fetchEmotionLogs();
  }, [isLoggedIn, userid, secureApiRequest]); // Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú, userId, secureApiRequest Î≥ÄÍ≤Ω Ïãú Ïû¨Ïã§Ìñâ

  // ÏùåÏÑ± Ïù∏Ïãù ÏÑ§Ï†ï useEffect
  useEffect(() => {
    const SpeechRecognition =
      window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      console.error("Ïù¥ Î∏åÎùºÏö∞Ï†ÄÏóêÏÑúÎäî ÏùåÏÑ± Ïù∏ÏãùÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.");
      return;
    }

    const recognition = new SpeechRecognition();
    recognition.lang = "ko-KR";
    recognition.continuous = false; // Ìïú Î¨∏Ïû•Ïù¥ ÎÅùÎÇòÎ©¥ Ïù∏Ïãù Ï¢ÖÎ£å
    recognition.interimResults = true;

    recognitionRef.current = recognition;

    recognition.onresult = (event) => {
      let interimTranscript = "";
      let finalTranscript = "";

      for (let i = event.resultIndex; i < event.results.length; ++i) {
        if (event.results[i].isFinal) {
          finalTranscript += event.results[i][0].transcript;
        } else {
          interimTranscript += event.results[i][0].transcript;
        }
      }
      setRecordText(finalTranscript || interimTranscript);
    };

    recognition.onerror = (event) => {
      console.error(`ÏùåÏÑ± Ïù∏Ïãù Ïò§Î•ò: ${event.error}`);
      if (event.error === "no-speech") {
        // alert('ÏùåÏÑ±Ïù¥ Í∞êÏßÄÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. ÎßàÏù¥ÌÅ¨Î•º ÌôïÏù∏ÌïòÍ≥† Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
      } else if (event.error === "audio-capture") {
        alert("ÎßàÏù¥ÌÅ¨ Ï†ëÍ∑º Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§. Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ïÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.");
      } else {
        alert("ÏùåÏÑ± Ïù∏Ïãù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
      }
      setIsListening(false);
    };

    recognition.onend = () => {
      setIsListening(false);
    };
  }, []);

  //ÌëúÏ†ïÍ∏∞Î∞ò Í∞êÏ†ïÎ∂ÑÏÑù ÏΩîÎìú (Ïã§ÏãúÍ∞Ñ Î∂ÑÏÑù Ìï®Ïàò)
  const handleEmotionClick = (emotion) => {
    setSelectedEmotion(emotion);
  };

  useEffect(() => {
    if (!showWebcamModal) return;
    console.log("[‚úÖ useEffect] ÏõπÏ∫† Î™®Îã¨ Ïó¥Î¶º");

    const initWebcam = async () => {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      console.log("[‚úÖ ÏõπÏ∫†] Ïä§Ìä∏Î¶º ÏãúÏûëÎê®");

      if (videoRef.current) {
        videoRef.current.srcObject = stream;
      }
    };

    initWebcam();

    const intervalId = setInterval(() => {
      console.log("[‚è±Ô∏è ÌÉÄÏù¥Î®∏] ÌîÑÎ†àÏûÑ Ï∫°Ï≤ò ÏãúÎèÑ");

      captureAndAnalyzeFrame();
    }, 3000);

    return () => {
      clearInterval(intervalId);
      if (videoRef.current?.srcObject) {
        videoRef.current.srcObject.getTracks().forEach((track) => track.stop());
        console.log("[üõë ÏõπÏ∫†] Ïä§Ìä∏Î¶º Ï†ïÏßÄ");
      }
    };
  }, [showWebcamModal]);

  //ÌëúÏ†ïÍ∏∞Î∞ò Í∞êÏ†ïÎ∂ÑÏÑù ÏΩîÎìú (ÌîÑÎ†àÏûÑ Ï∫°Ï≤ò Î∞è Flask Í∞êÏ†ï Î∂ÑÏÑù ÏöîÏ≤≠)
  const captureAndAnalyzeFrame = async () => {
    const video = videoRef.current;
    if (!video) {
      console.warn("[‚ö†Ô∏è Ï∫°Ï≤ò] videoRefÍ∞Ä ÎπÑÏñ¥ÏûàÏùå");
      return;
    }

    const canvas = document.createElement("canvas");
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const base64Image = canvas.toDataURL("image/jpeg");

    console.log("[üì∏ Ï∫°Ï≤ò] ÌîÑÎ†àÏûÑ Ï∫°Ï≤ò ÏôÑÎ£å");

    try {
      const response = await fetch(
        "http://localhost:5000/api/face/analyze-emotion",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ image: base64Image }),
        }
      );
      const result = await response.json();
      console.log("[üì¨ Flask ÏùëÎãµ] result:", result);

      const emotionMap = {
        happy: "ÌñâÎ≥µ",
        sad: "Ïä¨Ìîî",
        angry: "ÌôîÎÇ®",
        neutral: "ÌèâÏò®",
        fear: "Î∂àÏïà",
        disgust: "ÌôîÎÇ®",
        surprise: "Í≥†ÎØº",
      };

      if (result.success) {
        const engEmotion = result.emotion;
        const korEmotion = emotionMap[engEmotion]; // Ïó¨Í∏∞ÏÑú undefined Ìï¥Í≤∞Îê®

        console.log(
          "[üéØ Îß§ÌïëÎêú Í∞êÏ†ï] ÏòÅÏñ¥:",
          engEmotion,
          "‚û° ÌïúÍ∏Ä:",
          korEmotion
        );

        const matched = emotions.find((e) => e.emotionName === korEmotion);
        console.log("[üîç Í∞êÏ†ï Îß§Ïπ≠ Í≤∞Í≥º] matched:", matched);

        if (matched) {
          setSelectedEmotion(matched);
          setShowWebcamModal(false);
          console.log(
            "[‚úÖ Í∞êÏ†ï ÏÑ†ÌÉù ÏôÑÎ£å] Í∞êÏ†ï:",
            matched.emotionName,
            "Î™®Îã¨ Îã´Ìûò"
          );
        } else {
          console.warn("[‚ùå Í∞êÏ†ï Îß§Ïπ≠ Ïã§Ìå®] Ìï¥Îãπ Í∞êÏ†ï ÏóÜÏùå:", korEmotion);
        }
      } else {
        console.warn("[‚ùå Î∂ÑÏÑù Ïã§Ìå®] Flask result.success === false");
      }
    } catch (error) {
      console.error("[üí• ÏóêÎü¨] Í∞êÏ†ï Î∂ÑÏÑù Ï§ë Ïò§Î•ò:", error);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!selectedEmotion) {
      alert("Í∞êÏ†ïÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.");
      return;
    }
    if (!recordText.trim()) {
      alert("Ïò§ÎäòÏùò ÏÉùÍ∞ÅÍ≥º ÎäêÎÇåÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.");
      return;
    }
    if (!isLoggedIn) {
      alert("Î°úÍ∑∏Ïù∏ ÌõÑ Ïù¥Ïö©Ìï¥Ï£ºÏÑ∏Ïöî.");
      return;
    }

    try {
      await secureApiRequest("http://localhost:8888/seems/api/emotion-logs", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        data: {
          userId: userid,
          emotionId: selectedEmotion.emotionId,
          textContent: recordText,
        },
      });

      alert("Í∏∞Î°ùÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï†úÏ∂úÎêòÏóàÏäµÎãàÎã§!");
      setSelectedEmotion(null);
      setRecordText("");
      
      // Í∏∞Î°ù Ï†úÏ∂ú ÌõÑ ÏµúÏã† Í∏∞Î°ùÏùÑ Îã§Ïãú Î∂àÎü¨Ïò¥
      const response = await secureApiRequest(
        `http://localhost:8888/seems/api/emotion-logs/${userid}`
      );
      setEmotionLogs(response.data);
      
      // Ï†ÑÏó≠ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (ÎåÄÏãúÎ≥¥Îìú ÎèôÍ∏∞Ìôî)
      if (response.data && response.data.length > 0) {
        const today = new Date().toISOString().split('T')[0];
        const todayRecord = response.data.find(log => {
          const logDate = new Date(log.createdAt).toISOString().split('T')[0];
          return logDate === today;
        });
        
        console.log('Í∞êÏ†ï Í∏∞Î°ù Ï†úÏ∂ú ÌõÑ ÏùëÎãµ Îç∞Ïù¥ÌÑ∞:', response.data);
        console.log('Ïò§Îäò ÎÇ†Ïßú:', today);
        console.log('Ïò§Îäò Í∏∞Î°ù:', todayRecord);
        console.log('todayRecord.emotion:', todayRecord?.emotion);
        console.log('todayRecord.emotion Ï†ÑÏ≤¥ Íµ¨Ï°∞:', JSON.stringify(todayRecord?.emotion, null, 2));
        
        if (todayRecord) {
          // emotion Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞ ÌôïÏù∏ Î∞è ÏïàÏ†ÑÌïú Ï†ëÍ∑º
          let emotionName = 'unknown';
          console.log('Í∞êÏ†ï Ïù¥Î¶Ñ Ï∂îÏ∂ú Í≥ºÏ†ï:');
          console.log('- todayRecord.emotion:', todayRecord.emotion);
          console.log('- todayRecord.emotion.emotionName:', todayRecord.emotion?.emotionName);
          console.log('- todayRecord.emotion.name:', todayRecord.emotion?.name);
          console.log('- todayRecord.emotionName:', todayRecord.emotionName);
          
          if (todayRecord.emotion && todayRecord.emotion.emotionName) {
            emotionName = todayRecord.emotion.emotionName;
            console.log('- emotion.emotionName ÏÇ¨Ïö©:', emotionName);
          } else if (todayRecord.emotion && todayRecord.emotion.name) {
            emotionName = todayRecord.emotion.name;
            console.log('- emotion.name ÏÇ¨Ïö©:', emotionName);
          } else if (todayRecord.emotionName) {
            emotionName = todayRecord.emotionName;
            console.log('- emotionName ÏÇ¨Ïö©:', emotionName);
          } else if (todayRecord.emotion) {
            emotionName = todayRecord.emotion;
            console.log('- emotion ÏßÅÏ†ë ÏÇ¨Ïö©:', emotionName);
          }
          
          const emotionData = {
            emotion: emotionName,
            content: todayRecord.textContent,
            createdAt: todayRecord.createdAt
          };
          console.log('Ï†ÑÏó≠ ÏÉÅÌÉúÏóê ÏóÖÎç∞Ïù¥Ìä∏Ìï† Í∞êÏ†ï Îç∞Ïù¥ÌÑ∞:', emotionData);
          updateTodayEmotion(emotionData);
          console.log('Ï†ÑÏó≠ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å');
        } else {
          console.log('Ïò§Îäò ÎÇ†ÏßúÏùò Í∞êÏ†ï Í∏∞Î°ùÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå');
        }
      } else {
        console.log('Í∞êÏ†ï Í∏∞Î°ù Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏùå');
      }
    } catch (error) {
      console.error("Í∏∞Î°ù Ï†úÏ∂ú Ïã§Ìå®:", error);
      alert("Í∏∞Î°ù Ï†úÏ∂úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
    }
  };

  const handleCameraClick = () => {
    setShowWebcamModal(true);
  };

  const handleVoiceClick = () => {
    if (isListening) {
      recognitionRef.current.stop();
      setIsListening(false);
    } else {
      recognitionRef.current.start();
      setIsListening(true);
    }
  };

  return (
    <div className={styles.body}>
      <UserHeader />
      <main className={styles.main}>
        {/* <h1 className={styles['page-title']}>Í∞êÏ†ï Í∏∞Î°ù</h1> */}
        <div className={styles["record-grid"]}>
          <div className={styles["record-card"]}>
            <h3>Ïò§ÎäòÏùò Í∞êÏ†ï</h3>
            <div
              style={{
                display: "flex",
                alignItems: "center",
                justifyContent: "flex-end",
                marginBottom: "4px",
              }}
            >
              <button
                type="button"
                className={styles["camera-btn"]}
                title="Ï¥¨ÏòÅ"
                onClick={handleCameraClick}
              >
                <img
                  src="/images/camera.png"
                  alt="Ï¥¨ÏòÅ"
                  style={{ width: "22px", height: "auto", display: "block" }}
                />
              </button>
              <input
                type="file"
                accept="image/*"
                capture="user"
                id="cameraInput"
                className={styles["camera-input"]}
              />
            </div>
            <div className={styles["emotion-grid"]}>
              {emotions.map((emotion) => (
                <div
                  key={emotion.emotionId}
                  className={`${styles["emotion-item"]} ${selectedEmotion && selectedEmotion.emotionId === emotion.emotionId ? styles.selected : ""}`}
                  onClick={() => handleEmotionClick(emotion)}
                >
                  <span className={styles["emotion-emoji"]}>
                    {emotion.emoji}
                  </span>
                  <span className={styles["emotion-label"]}>
                    {emotion.emotionName}
                  </span>
                </div>
              ))}
            </div>
            <form className={styles["record-form"]} onSubmit={handleSubmit}>
              <div className={styles["form-group"]}>
                <label htmlFor="record-text">Ïò§ÎäòÏùò ÏÉùÍ∞ÅÍ≥º ÎäêÎÇå</label>
                <textarea
                  id="record-text"
                  placeholder="Ïò§Îäò ÏûàÏóàÎçò ÏùºÏù¥ÎÇò ÎäêÎÇÄ Í∞êÏ†ïÏùÑ ÏûêÏú†Î°≠Í≤å Ï†ÅÏñ¥Î≥¥ÏÑ∏Ïöî..."
                  value={recordText}
                  onChange={(e) => setRecordText(e.target.value)}
                ></textarea>
                <button
                  type="button"
                  className={`${styles["voice-btn"]} ${isListening ? styles.listening : ""}`}
                  title="ÏùåÏÑ± ÏûÖÎ†•"
                  onClick={handleVoiceClick}
                >
                  <img
                    src={
                      isListening ? "/images/stop_1.jpg" : "/images/rec_1.png"
                    }
                    alt={isListening ? "ÎÖπÏùå Ï§ëÏßÄ" : "ÏùåÏÑ± ÏûÖÎ†•"}
                  />
                </button>
              </div>
              <button type="submit" className={styles["submit-btn"]}>
                Í∏∞Î°ùÌïòÍ∏∞
              </button>
            </form>
          </div>
        </div>
        <div className={styles["history-section"]}>
          <h3>ÏµúÍ∑º Í∏∞Î°ù</h3>
          <div className={styles["history-list"]}>
            {emotionLogs.length > 0 ? (
              emotionLogs.map((log) => (
                <div key={log.emotionLogId} className={styles["history-item"]}>
                  <div className={styles["history-emoji"]}>
                    {log.emotion.emoji}
                  </div>
                  <div className={styles["history-content"]}>
                    <div className={styles["history-date"]}>
                      {new Date(log.createdAt).toLocaleDateString("ko-KR", {
                        year: "numeric",
                        month: "2-digit",
                        day: "2-digit",
                      })}
                    </div>
                    <p className={styles["history-text"]}>{log.textContent}</p>
                  </div>
                </div>
              ))
            ) : (
              <p>ÏïÑÏßÅ Í∏∞Î°ùÎêú Í∞êÏ†ïÏù¥ ÏóÜÏäµÎãàÎã§.</p>
            )}
          </div>
        </div>
      </main>
      //ÌëúÏ†ïÍ∏∞Î∞ò Í∞êÏ†ïÎ∂ÑÏÑù Î™®Îã¨Ï∞Ω
      {showWebcamModal && (
        <div className={styles["webcam-modal"]}>
          <div className={styles["webcam-container"]}>
            <video
              ref={videoRef}
              autoPlay
              muted
              playsInline
              style={{ width: "100%" }}
            />
            <button
              onClick={() => setShowWebcamModal(false)}
              className={styles["close-webcam"]}
            >
              Îã´Í∏∞
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default EmotionRecordPage;
