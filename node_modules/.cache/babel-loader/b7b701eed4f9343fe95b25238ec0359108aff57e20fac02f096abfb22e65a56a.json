{"ast":null,"code":"var _jsxFileName = \"D:\\\\seems_react_workspace\\\\seems_react\\\\src\\\\AuthProvider.js\",\n  _s = $RefreshSig$();\n// 전역 상태 관리자 : 로그인 여부 상태, accessToken 과 refreshToken 상태 관리가 목적임\n// 비동기 요청시 토큰 상태 확인 작업도 전역으로 관리할 것임\n// 1. 로그인 상태 관리 : accessToken, refreshToken 으로 로그인 상태 설정\n// 2. 토큰 저장 및 파싱 : JWT 에서 사용자 정보(role, username 등) 파싱\n// 3. 토큰 자동 재발급 : accessToken or refreshToken 만료시 재발급 처리 => refreshToken 만료시 로그인연장 여부 확인\n// 4. 로그아웃 및 리다이렉션 : 토큰 만료시 로그아웃 처리\n// 5. 안전한 서버측 api 요청 : 비동기 요청시 인증 토큰 포함해서 요청 수행 처리\n\nimport { createContext, useState, useEffect } from 'react';\nimport apiClient from './utils/axios';\n\n// 전역(global) 사용을 위해 함수 밖에서 선언함\n// Context 생성 : 외부 컴포넌트가 import 해서 사용할 수 있도록 export 지정함\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const AuthContext = /*#__PURE__*/createContext();\n\n// accessToken 을 전달받아서, 사용자 정보 추출을 위한 파싱 작업\n// 필요한 이유 : JWT 는 base64Url 로 인코딩해서 클라이언트로 전송하였음\n// 클라이언트는 받아서 replace 를 통해 base64 로 변환 후 디코딩 처리 필요함\n// JWT 에서 Payload(두번째, . 구분자 사이의 값)를 파싱하여 사용자 정보 추출하는 함수 작성함\nconst parseAccessToken = token => {\n  if (!token) return null;\n  try {\n    // 전달받은 토큰에서 payload 부분 추출함\n    const base64Url = token.split('.')[1];\n    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n    const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => `%${('00' + c.charCodeAt(0).toString(16)).slice(-2)}`)\n    // 빽틱 (`) 사용할 것\n    .join(''));\n    return JSON.parse(jsonPayload); // 페이로드 문자열을 json 객체로 파싱해서 리턴함\n  } catch (error) {\n    console.error('AccessToken 파싱 오류 : ', error);\n    return null;\n  }\n};\n\n// Context Provider 컴포넌트 : export function AuthProvider() {} 과 같음\n// function AuthProvider() {}  export default 함수명;  과 같음\nexport const AuthProvider = ({\n  children\n}) => {\n  _s();\n  // 매개변수 children : 전역 상태 관리자를 이용하는 하위 컴포넌트 (페이지)를 말함\n\n  // 다른 컴포넌트에서 로그인 확인과 사용자 정보 이용을 위해 준비함\n  const [authInfo, setAuthInfo] = useState({\n    isLoggedIn: false,\n    role: '',\n    username: ''\n  });\n\n  // 브라우저에 이 컴포넌트가 랜더링될 때 (로드되어서 출력) 작동되는 훅임\n  // window.onload = function(){ 페이지 출력될 때 자동 실행하는 코드 구문};  과 같은 기능을 수행하는 훅임\n  // 처리 기능 : 마운트시 토큰 검사\n  useEffect(() => {\n    // 초기화 시 토큰 확인 및 상태 설정\n    const accessToken = localStorage.getItem('accessToken');\n    const refreshToken = localStorage.getItem('refreshToken');\n    console.log('useEffect : ', accessToken, refreshToken);\n    if (accessToken && refreshToken) {\n      const parsedToken = parseAccessToken(accessToken);\n      console.log('useEffect 실행 : ', parsedToken);\n      console.log('-----------------------------');\n      if (parsedToken) {\n        setAuthInfo({\n          isLoggedIn: true,\n          role: parsedToken.role,\n          username: parsedToken.userName // ✅ 서버 필드명과 일치\n        });\n      } else {\n        // 토큰 파싱이 실패한 경우 로그아웃 처리\n        logoutAndRedirect();\n      }\n    }\n  }, []); //useEffect\n\n  // 로그아웃 함수\n  const logoutAndRedirect = () => {\n    if (!authInfo.isLoggedIn) return;\n    localStorage.clear();\n    setAuthInfo({\n      isLoggedIn: false,\n      role: '',\n      username: ''\n    });\n    window.location.href = '/';\n  }; // logoutAndRedirect\n\n  // 로그인 성공시 공통 토큰 저장 처리 및 상태 업데이트 함수\n  const updateTokens = (accessToken, refreshToken) => {\n    if (accessToken) {\n      localStorage.setItem('accessToken', accessToken);\n      const parsedToken = parseAccessToken(accessToken);\n      console.log('AuthProvider updateTokens : ', parsedToken);\n      if (parsedToken) {\n        setAuthInfo({\n          isLoggedIn: true,\n          role: parsedToken.role,\n          username: parsedToken.userName // ✅ 서버 필드명과 일치\n        });\n        console.log('authInfo : ', authInfo);\n      } else {\n        // 파싱 실패시 로그아웃 처리\n        logoutAndRedirect();\n      }\n    }\n    if (refreshToken) {\n      localStorage.setItem('refreshToken', refreshToken);\n    }\n  }; // updateTokens\n\n  // 공통으로 사용할 서버측 API 요청 처리용 함수 (로그인 상태에서 요청하는 서비스들)\n  // 요청 전에 토큰 만료 확인, accessToken 만료시 refreshToken 으로 토큰 재발급 요청\n  // refreshToken 만료시에는 로그인 연장 여부 확인하고, refreshToken 재발급 요청\n  // 두 개의 토큰이 정상일 때 API 요청 처리에 대한 기능 구현\n  const secureApiRequest = async (url, options = {}, retry = true) => {\n    console.log('AuthProvider.secureApiRequest 실행!!!!');\n    const accessToken = localStorage.getItem('accessToken');\n    const refreshToken = localStorage.getItem('refreshToken');\n    if (!accessToken || !refreshToken) {\n      throw new Error('AccessToken 또는 RefreshToken 이 없습니다.');\n    }\n    try {\n      const method = options.method || 'GET';\n      const data = options.body || null;\n\n      // 서버측으로 서비스 요청 보내고 결과 받기\n      const response = await apiClient({\n        url,\n        method,\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          //빽틱 사용할 것\n          RefreshToken: `Bearer ${refreshToken}` //빽틱 사용할 것\n        },\n        data\n      });\n      return response; // 요청 성공시 리턴함\n    } catch (error) {\n      var _error$response, _error$response2, _error$response3, _error$response4, _error$response5;\n      console.error('API 요청 실패 - 상태 코드 : ', (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status);\n      console.error('API 응답 해더 : ', (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.headers);\n      console.error('API 응답 데이터 : ', (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.data);\n      const tokenExpiredHeader = (_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.headers['token-expired'];\n      if (((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.status) === 401 && retry) {\n        // ststus.code : 401 (UnAuthrized 임)\n        // RefreshToken 만료시 로그인 연장 여부 확인\n        if (tokenExpiredHeader === 'RefreshToken') {\n          const confirmExtend = window.confirm('로그인 세션이 만료되었습니다. 로그인 연장하시겠습니까?');\n          if (confirmExtend) {\n            console.log('로그인 연장 동의 누름...');\n            try {\n              // RefreshToken 재발급 요청함수 실행\n              await handleReissueTokens(true);\n              // RefreshToken 재발급되면, 서버측 API 다시 요청함\n              return secureApiRequest(url, options, false); // 재시도 요청함\n            } catch (refreshError) {\n              var _refreshError$respons;\n              console.error('로그인 연장 실패 : ', (_refreshError$respons = refreshError.response) === null || _refreshError$respons === void 0 ? void 0 : _refreshError$respons.data);\n              alert('로그아웃 되었습니다. 다시 로그인하세요.');\n              logoutAndRedirect();\n            }\n          } else {\n            // 로그인 연장을 선택하지 않았다면...\n            alert('로그인이 연장되지 않았습니다. 다시 로그인하세요.');\n            logoutAndRedirect();\n          }\n        } // 리프레시토큰 만료되었을 때\n\n        // AccessToken 만료시 RefreshToken 으로 AccessToken 재발급\n        if (tokenExpiredHeader === 'AccessToken') {\n          console.warn('AccessToken 만료, RefreshToken 으로 재발급 시도중....');\n          try {\n            await handleReissueTokens();\n            return secureApiRequest(url, options, false); // API 재호출 시도\n          } catch (accessError) {\n            var _accessError$response;\n            console.error('AccessToken 재발급 실패...', (_accessError$response = accessError.response) === null || _accessError$response === void 0 ? void 0 : _accessError$response.data);\n            logoutAndRedirect();\n          }\n        }\n      }\n      throw error; // 다른 에러 처리\n    }\n  }; //  secureApiRequest\n\n  // AccessToken or RefreshToken 재발급 처리 함수 ===========================\n  const handleReissueTokens = async (extendLogin = false) => {\n    var _localStorage$getItem, _localStorage$getItem2;\n    let accessToken = (_localStorage$getItem = localStorage.getItem('accessToken')) === null || _localStorage$getItem === void 0 ? void 0 : _localStorage$getItem.trim();\n    let refreshToken = (_localStorage$getItem2 = localStorage.getItem('refreshToken')) === null || _localStorage$getItem2 === void 0 ? void 0 : _localStorage$getItem2.trim();\n    if (!accessToken || !refreshToken) {\n      console.error('Reissue 요청 실패 : 토큰이 존재하지 않습니다.');\n      alert('로그아웃 되었습니다. 다시 로그인 하세요');\n      logoutAndRedirect();\n      return;\n    }\n    try {\n      var _response$headers$Aut, _response$headers$Aut2, _response$headers$Ref, _response$headers$Ref2;\n      console.log('Reissue 요청 - AccessToken : ', accessToken);\n      console.log('Ressiue 요청 - RefreshToken : ', refreshToken);\n\n      //토큰 재발급 요청하고 결과 받기\n      const response = await apiClient.post('/reissue', null, {\n        headers: {\n          Authorization: `Bearer ${accessToken}`,\n          RefreshToken: `Bearer ${refreshToken}`,\n          ExtendLogin: extendLogin ? 'true' : 'false'\n        }\n      });\n      console.log('Reissue 성공 - 응답 해더 : ', response.headers);\n      // 새로 발급된 토큰으로 업데이트\n      updateTokens((_response$headers$Aut = response.headers['Authorization']) === null || _response$headers$Aut === void 0 ? void 0 : (_response$headers$Aut2 = _response$headers$Aut.split(' ')[1]) === null || _response$headers$Aut2 === void 0 ? void 0 : _response$headers$Aut2.trim(), // Bearer token 분리\n      (_response$headers$Ref = response.headers['Refresh-Token']) === null || _response$headers$Ref === void 0 ? void 0 : (_response$headers$Ref2 = _response$headers$Ref.split(' ')[1]) === null || _response$headers$Ref2 === void 0 ? void 0 : _response$headers$Ref2.trim());\n    } catch (error) {\n      var _error$response6, _error$response7, _error$response8, _error$response9;\n      console.error('Reissue 실패 - 상태코드 : ', (_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.status);\n      console.error('Reissue 실패 - 응답 데이터 : ', (_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : _error$response7.data);\n      const expiredTokenType = (_error$response8 = error.response) === null || _error$response8 === void 0 ? void 0 : _error$response8.headers['token-expired'];\n      if (expiredTokenType === 'RefreshToken' || ((_error$response9 = error.response) === null || _error$response9 === void 0 ? void 0 : _error$response9.data) === 'Session Expired') {\n        alert('세션이 만료되었습니다. 다시 로그인해주세요.');\n        logoutAndRedirect();\n      } else if (expiredTokenType === 'AccessToken') {\n        console.warn('AccessToken 만료됨. RefreshToken으로 재발급 시도 중...');\n        return await handleReissueTokens();\n      } else {\n        console.error('Reissue 중 예상치 못한 오류 발생:', error.message);\n        logoutAndRedirect();\n      }\n    }\n  }; // handleReissueTokens\n\n  // 다른 컴포넌트에 제공할 함수나 데이터는 반드시 AuthContext.Provider 의 value 에 추가해 놓아야 함\n  // authInfo 작성하면 다른 컴포넌트에서 사용시 authInfo 로만 사용할 수 있음, authInfo.isLoggedIn\n  // ...authInfo 작성하면 다름 컴포넌트에서 사용시, isLoggedIn 으로 바로 사용 가능함\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: {\n      ...authInfo,\n      setAuthInfo,\n      secureApiRequest,\n      logoutAndRedirect,\n      updateTokens\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 250,\n    columnNumber: 5\n  }, this);\n}; // AuthProvider\n\n// 함수 앞에 export 사용하면, export default 함수명; 사용 안 함\n_s(AuthProvider, \"fzuDcqGd6XiZwd22uVv7uU2HfFs=\");\n_c = AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["createContext","useState","useEffect","apiClient","jsxDEV","_jsxDEV","AuthContext","parseAccessToken","token","base64Url","split","base64","replace","jsonPayload","decodeURIComponent","atob","map","c","charCodeAt","toString","slice","join","JSON","parse","error","console","AuthProvider","children","_s","authInfo","setAuthInfo","isLoggedIn","role","username","accessToken","localStorage","getItem","refreshToken","log","parsedToken","userName","logoutAndRedirect","clear","window","location","href","updateTokens","setItem","secureApiRequest","url","options","retry","Error","method","data","body","response","headers","Authorization","RefreshToken","_error$response","_error$response2","_error$response3","_error$response4","_error$response5","status","tokenExpiredHeader","confirmExtend","confirm","handleReissueTokens","refreshError","_refreshError$respons","alert","warn","accessError","_accessError$response","extendLogin","_localStorage$getItem","_localStorage$getItem2","trim","_response$headers$Aut","_response$headers$Aut2","_response$headers$Ref","_response$headers$Ref2","post","ExtendLogin","_error$response6","_error$response7","_error$response8","_error$response9","expiredTokenType","message","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/seems_react_workspace/seems_react/src/AuthProvider.js"],"sourcesContent":["// 전역 상태 관리자 : 로그인 여부 상태, accessToken 과 refreshToken 상태 관리가 목적임\r\n// 비동기 요청시 토큰 상태 확인 작업도 전역으로 관리할 것임\r\n// 1. 로그인 상태 관리 : accessToken, refreshToken 으로 로그인 상태 설정\r\n// 2. 토큰 저장 및 파싱 : JWT 에서 사용자 정보(role, username 등) 파싱\r\n// 3. 토큰 자동 재발급 : accessToken or refreshToken 만료시 재발급 처리 => refreshToken 만료시 로그인연장 여부 확인\r\n// 4. 로그아웃 및 리다이렉션 : 토큰 만료시 로그아웃 처리\r\n// 5. 안전한 서버측 api 요청 : 비동기 요청시 인증 토큰 포함해서 요청 수행 처리\r\n\r\nimport { createContext, useState, useEffect } from 'react';\r\nimport apiClient from './utils/axios';\r\n\r\n// 전역(global) 사용을 위해 함수 밖에서 선언함\r\n// Context 생성 : 외부 컴포넌트가 import 해서 사용할 수 있도록 export 지정함\r\nexport const AuthContext = createContext();\r\n\r\n// accessToken 을 전달받아서, 사용자 정보 추출을 위한 파싱 작업\r\n// 필요한 이유 : JWT 는 base64Url 로 인코딩해서 클라이언트로 전송하였음\r\n// 클라이언트는 받아서 replace 를 통해 base64 로 변환 후 디코딩 처리 필요함\r\n// JWT 에서 Payload(두번째, . 구분자 사이의 값)를 파싱하여 사용자 정보 추출하는 함수 작성함\r\nconst parseAccessToken = (token) => {\r\n  if (!token) return null;\r\n  try {\r\n    // 전달받은 토큰에서 payload 부분 추출함\r\n    const base64Url = token.split('.')[1];\r\n    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\r\n    const jsonPayload = decodeURIComponent(\r\n      atob(base64)\r\n        .split('')\r\n        .map((c) => `%${('00' + c.charCodeAt(0).toString(16)).slice(-2)}`)\r\n        // 빽틱 (`) 사용할 것\r\n        .join('')\r\n    );\r\n    return JSON.parse(jsonPayload); // 페이로드 문자열을 json 객체로 파싱해서 리턴함\r\n  } catch (error) {\r\n    console.error('AccessToken 파싱 오류 : ', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n// Context Provider 컴포넌트 : export function AuthProvider() {} 과 같음\r\n// function AuthProvider() {}  export default 함수명;  과 같음\r\nexport const AuthProvider = ({ children }) => {\r\n  // 매개변수 children : 전역 상태 관리자를 이용하는 하위 컴포넌트 (페이지)를 말함\r\n\r\n  // 다른 컴포넌트에서 로그인 확인과 사용자 정보 이용을 위해 준비함\r\n  const [authInfo, setAuthInfo] = useState({\r\n    isLoggedIn: false,\r\n    role: '',\r\n    username: '',\r\n  });\r\n\r\n  // 브라우저에 이 컴포넌트가 랜더링될 때 (로드되어서 출력) 작동되는 훅임\r\n  // window.onload = function(){ 페이지 출력될 때 자동 실행하는 코드 구문};  과 같은 기능을 수행하는 훅임\r\n  // 처리 기능 : 마운트시 토큰 검사\r\n  useEffect(() => {\r\n    // 초기화 시 토큰 확인 및 상태 설정\r\n    const accessToken = localStorage.getItem('accessToken');\r\n    const refreshToken = localStorage.getItem('refreshToken');\r\n    console.log('useEffect : ', accessToken, refreshToken);\r\n    if (accessToken && refreshToken) {\r\n      const parsedToken = parseAccessToken(accessToken);\r\n      console.log('useEffect 실행 : ', parsedToken);\r\n      console.log('-----------------------------');\r\n\r\n      if (parsedToken) {\r\n        setAuthInfo({\r\n          isLoggedIn: true,\r\n          role: parsedToken.role,\r\n          username: parsedToken.userName, // ✅ 서버 필드명과 일치\r\n        });\r\n      } else {\r\n        // 토큰 파싱이 실패한 경우 로그아웃 처리\r\n        logoutAndRedirect();\r\n      }\r\n    }\r\n  }, []); //useEffect\r\n\r\n  // 로그아웃 함수\r\n  const logoutAndRedirect = () => {\r\n    if (!authInfo.isLoggedIn) return;\r\n\r\n    localStorage.clear();\r\n    setAuthInfo({ isLoggedIn: false, role: '', username: '' });\r\n    window.location.href = '/';\r\n  }; // logoutAndRedirect\r\n\r\n  // 로그인 성공시 공통 토큰 저장 처리 및 상태 업데이트 함수\r\n  const updateTokens = (accessToken, refreshToken) => {\r\n    if (accessToken) {\r\n      localStorage.setItem('accessToken', accessToken);\r\n      const parsedToken = parseAccessToken(accessToken);\r\n      console.log('AuthProvider updateTokens : ', parsedToken);\r\n\r\n      if (parsedToken) {\r\n        setAuthInfo({\r\n          isLoggedIn: true,\r\n          role: parsedToken.role,\r\n          username: parsedToken.userName, // ✅ 서버 필드명과 일치\r\n        });\r\n        console.log('authInfo : ', authInfo);\r\n      } else {\r\n        // 파싱 실패시 로그아웃 처리\r\n        logoutAndRedirect();\r\n      }\r\n    }\r\n\r\n    if (refreshToken) {\r\n      localStorage.setItem('refreshToken', refreshToken);\r\n    }\r\n  }; // updateTokens\r\n\r\n  // 공통으로 사용할 서버측 API 요청 처리용 함수 (로그인 상태에서 요청하는 서비스들)\r\n  // 요청 전에 토큰 만료 확인, accessToken 만료시 refreshToken 으로 토큰 재발급 요청\r\n  // refreshToken 만료시에는 로그인 연장 여부 확인하고, refreshToken 재발급 요청\r\n  // 두 개의 토큰이 정상일 때 API 요청 처리에 대한 기능 구현\r\n  const secureApiRequest = async (url, options = {}, retry = true) => {\r\n    console.log('AuthProvider.secureApiRequest 실행!!!!');\r\n    const accessToken = localStorage.getItem('accessToken');\r\n    const refreshToken = localStorage.getItem('refreshToken');\r\n\r\n    if (!accessToken || !refreshToken) {\r\n      throw new Error('AccessToken 또는 RefreshToken 이 없습니다.');\r\n    }\r\n\r\n    try {\r\n      const method = options.method || 'GET';\r\n      const data = options.body || null;\r\n\r\n      // 서버측으로 서비스 요청 보내고 결과 받기\r\n      const response = await apiClient({\r\n        url,\r\n        method,\r\n        headers: {\r\n          Authorization: `Bearer ${accessToken}`, //빽틱 사용할 것\r\n          RefreshToken: `Bearer ${refreshToken}`, //빽틱 사용할 것\r\n        },\r\n        data,\r\n      });\r\n\r\n      return response; // 요청 성공시 리턴함\r\n    } catch (error) {\r\n      console.error('API 요청 실패 - 상태 코드 : ', error.response?.status);\r\n      console.error('API 응답 해더 : ', error.response?.headers);\r\n      console.error('API 응답 데이터 : ', error.response?.data);\r\n\r\n      const tokenExpiredHeader = error.response?.headers['token-expired'];\r\n\r\n      if (error.response?.status === 401 && retry) {\r\n        // ststus.code : 401 (UnAuthrized 임)\r\n        // RefreshToken 만료시 로그인 연장 여부 확인\r\n        if (tokenExpiredHeader === 'RefreshToken') {\r\n          const confirmExtend = window.confirm(\r\n            '로그인 세션이 만료되었습니다. 로그인 연장하시겠습니까?'\r\n          );\r\n          if (confirmExtend) {\r\n            console.log('로그인 연장 동의 누름...');\r\n            try {\r\n              // RefreshToken 재발급 요청함수 실행\r\n              await handleReissueTokens(true);\r\n              // RefreshToken 재발급되면, 서버측 API 다시 요청함\r\n              return secureApiRequest(url, options, false); // 재시도 요청함\r\n            } catch (refreshError) {\r\n              console.error('로그인 연장 실패 : ', refreshError.response?.data);\r\n              alert('로그아웃 되었습니다. 다시 로그인하세요.');\r\n              logoutAndRedirect();\r\n            }\r\n          } else {\r\n            // 로그인 연장을 선택하지 않았다면...\r\n            alert('로그인이 연장되지 않았습니다. 다시 로그인하세요.');\r\n            logoutAndRedirect();\r\n          }\r\n        } // 리프레시토큰 만료되었을 때\r\n\r\n        // AccessToken 만료시 RefreshToken 으로 AccessToken 재발급\r\n        if (tokenExpiredHeader === 'AccessToken') {\r\n          console.warn('AccessToken 만료, RefreshToken 으로 재발급 시도중....');\r\n          try {\r\n            await handleReissueTokens();\r\n            return secureApiRequest(url, options, false); // API 재호출 시도\r\n          } catch (accessError) {\r\n            console.error(\r\n              'AccessToken 재발급 실패...',\r\n              accessError.response?.data\r\n            );\r\n            logoutAndRedirect();\r\n          }\r\n        }\r\n      }\r\n\r\n      throw error; // 다른 에러 처리\r\n    }\r\n  }; //  secureApiRequest\r\n\r\n  // AccessToken or RefreshToken 재발급 처리 함수 ===========================\r\n  const handleReissueTokens = async (extendLogin = false) => {\r\n    let accessToken = localStorage.getItem('accessToken')?.trim();\r\n    let refreshToken = localStorage.getItem('refreshToken')?.trim();\r\n\r\n    if (!accessToken || !refreshToken) {\r\n      console.error('Reissue 요청 실패 : 토큰이 존재하지 않습니다.');\r\n      alert('로그아웃 되었습니다. 다시 로그인 하세요');\r\n      logoutAndRedirect();\r\n      return;\r\n    }\r\n\r\n    try {\r\n      console.log('Reissue 요청 - AccessToken : ', accessToken);\r\n      console.log('Ressiue 요청 - RefreshToken : ', refreshToken);\r\n\r\n      //토큰 재발급 요청하고 결과 받기\r\n      const response = await apiClient.post('/reissue', null, {\r\n        headers: {\r\n          Authorization: `Bearer ${accessToken}`,\r\n          RefreshToken: `Bearer ${refreshToken}`,\r\n          ExtendLogin: extendLogin ? 'true' : 'false',\r\n        },\r\n      });\r\n\r\n      console.log('Reissue 성공 - 응답 해더 : ', response.headers);\r\n      // 새로 발급된 토큰으로 업데이트\r\n      updateTokens(\r\n        response.headers['Authorization']?.split(' ')[1]?.trim(), // Bearer token 분리\r\n        response.headers['Refresh-Token']?.split(' ')[1]?.trim()\r\n      );\r\n    } catch (error) {\r\n      console.error('Reissue 실패 - 상태코드 : ', error.response?.status);\r\n      console.error('Reissue 실패 - 응답 데이터 : ', error.response?.data);\r\n\r\n      const expiredTokenType = error.response?.headers['token-expired'];\r\n      if (\r\n        expiredTokenType === 'RefreshToken' ||\r\n        error.response?.data === 'Session Expired'\r\n      ) {\r\n        alert('세션이 만료되었습니다. 다시 로그인해주세요.');\r\n        logoutAndRedirect();\r\n      } else if (expiredTokenType === 'AccessToken') {\r\n        console.warn('AccessToken 만료됨. RefreshToken으로 재발급 시도 중...');\r\n        return await handleReissueTokens();\r\n      } else {\r\n        console.error('Reissue 중 예상치 못한 오류 발생:', error.message);\r\n        logoutAndRedirect();\r\n      }\r\n    }\r\n  }; // handleReissueTokens\r\n\r\n  // 다른 컴포넌트에 제공할 함수나 데이터는 반드시 AuthContext.Provider 의 value 에 추가해 놓아야 함\r\n  // authInfo 작성하면 다른 컴포넌트에서 사용시 authInfo 로만 사용할 수 있음, authInfo.isLoggedIn\r\n  // ...authInfo 작성하면 다름 컴포넌트에서 사용시, isLoggedIn 으로 바로 사용 가능함\r\n  return (\r\n    <AuthContext.Provider\r\n      value={{\r\n        ...authInfo,\r\n        setAuthInfo,\r\n        secureApiRequest,\r\n        logoutAndRedirect,\r\n        updateTokens,\r\n      }}\r\n    >\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n}; // AuthProvider\r\n\r\n// 함수 앞에 export 사용하면, export default 함수명; 사용 안 함"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}